// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

/**
 * @title UnboundedFlashloanRisk
 * @dev A contract demonstrating various unbounded flashloan risks
 *      that can be detected by the unbounded-flashloan-risk detector
 */
contract UnboundedFlashloanRisk {
    address public owner;
    mapping(address => uint256) public tokenBalances;
    uint256 public totalLiquidity;
    
    // Typically, protocols should have limits and fees
    uint256 public maxFlashLoanAmount; // Not enforced in vulnerable functions
    uint256 public flashLoanFeePercentage; // Zero in vulnerable scenarios
    
    // Events
    event FlashLoan(address token, address recipient, uint256 amount);
    event LiquidityAdded(address token, uint256 amount);
    event LiquidityRemoved(address token, uint256 amount);
    
    constructor() {
        owner = msg.sender;
        // Should be initialized, but intentionally left at zero to demonstrate the vulnerability
        maxFlashLoanAmount = 0; // Unlimited by default
        flashLoanFeePercentage = 0; // No fee by default
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not authorized");
        _;
    }
    
    // Admin functions to configure limits and fees
    function setMaxFlashLoanAmount(uint256 _maxAmount) external onlyOwner {
        maxFlashLoanAmount = _maxAmount;
    }
    
    function setFlashLoanFeePercentage(uint256 _feePercentage) external onlyOwner {
        flashLoanFeePercentage = _feePercentage;
    }
    
    // Liquidity functions
    function addLiquidity(address token, uint256 amount) external {
        // In a real implementation, tokens would be transferred here
        tokenBalances[token] += amount;
        totalLiquidity += amount;
        emit LiquidityAdded(token, amount);
    }
    
    function removeLiquidity(address token, uint256 amount) external onlyOwner {
        require(tokenBalances[token] >= amount, "Insufficient liquidity");
        // In a real implementation, tokens would be transferred here
        tokenBalances[token] -= amount;
        totalLiquidity -= amount;
        emit LiquidityRemoved(token, amount);
    }
    
    // ======= VULNERABLE FLASHLOAN IMPLEMENTATIONS =======
    
    /**
     * @dev Flashloan without amount limits
     * Vulnerable pattern: No maximum amount check
     */
    function flashLoanWithoutLimits(
        address token,
        address recipient,
        uint256 amount,
        bytes calldata data
    ) external returns (bool) {
        // Missing check: require(amount <= maxFlashLoanAmount, "Exceeds maximum flashloan amount");
        
        // Check only available balance
        require(tokenBalances[token] >= amount, "Insufficient liquidity");
        
        // Record the balance before the loan for validation later
        uint256 balanceBefore = tokenBalances[token];
        
        // In a real implementation, tokens would be transferred to the recipient here
        
        // Execute the callback on the recipient
        IFlashLoanReceiver(recipient).executeOperation(token, amount, 0, data);
        
        // Verify that tokens have been returned
        require(tokenBalances[token] >= balanceBefore, "Flashloan not repaid");
        
        // NOTE: No fee is charged - this is part of the vulnerability
        
        emit FlashLoan(token, recipient, amount);
        return true;
    }
    
    /**
     * @dev Flashloan without fees
     * Vulnerable pattern: No fee charged for the loan
     */
    function flashLoanWithoutFees(
        address token,
        address recipient,
        uint256 amount,
        bytes calldata data
    ) external returns (bool) {
        // There is a limit check here, but still vulnerable because there's no fee
        if (maxFlashLoanAmount > 0) {
            require(amount <= maxFlashLoanAmount, "Exceeds maximum flashloan amount");
        }
        
        require(tokenBalances[token] >= amount, "Insufficient liquidity");
        
        uint256 balanceBefore = tokenBalances[token];
        
        // In a real implementation, tokens would be transferred to the recipient here
        
        // Execute the callback on the recipient
        IFlashLoanReceiver(recipient).executeOperation(token, amount, 0, data);
        
        // Verify that tokens have been returned
        require(tokenBalances[token] >= balanceBefore, "Flashloan not repaid");
        
        // NOTE: There should be a fee calculation here:
        // uint256 fee = (amount * flashLoanFeePercentage) / 10000;
        // require(tokenBalances[token] >= balanceBefore + fee, "Fee not paid");
        
        emit FlashLoan(token, recipient, amount);
        return true;
    }
    
    /**
     * @dev Flashloan with both vulnerabilities and additional unsafe patterns
     * Vulnerable pattern: No limits, no fees, and unsafe callback handling
     */
    function unsafeFlashLoan(
        address token,
        address recipient,
        uint256 amount,
        bytes calldata data
    ) external returns (bool) {
        // No limit check
        // No fee mechanism
        
        require(tokenBalances[token] >= amount, "Insufficient liquidity");
        
        // Unsafe - doesn't track the balance before
        // In a real implementation, tokens would be transferred to the recipient here
        
        // Unsafe external call without checking the return value
        (bool success, ) = recipient.call(
            abi.encodeWithSignature(
                "executeOperation(address,uint256,uint256,bytes)",
                token, amount, 0, data
            )
        );
        
        // No verification that the loan was repaid properly
        
        emit FlashLoan(token, recipient, amount);
        return true;
    }
    
    /**
     * @dev The correct implementation for comparison
     * Secure pattern: Has limits, charges fees, proper validation
     */
    function secureFlashLoan(
        address token,
        address recipient,
        uint256 amount,
        bytes calldata data
    ) external returns (bool) {
        // Enforce maximum amount
        require(maxFlashLoanAmount > 0, "Flash loans not properly configured");
        require(amount <= maxFlashLoanAmount, "Exceeds maximum flashloan amount");
        
        // Check available liquidity
        require(tokenBalances[token] >= amount, "Insufficient liquidity");
        
        // Calculate fee
        uint256 fee = (amount * flashLoanFeePercentage) / 10000;
        
        // Record balance before the loan
        uint256 balanceBefore = tokenBalances[token];
        
        // In a real implementation, tokens would be transferred to the recipient here
        
        // Execute callback
        bool success = IFlashLoanReceiver(recipient).executeOperation(token, amount, fee, data);
        require(success, "Callback failed");
        
        // Verify loan repayment with fee
        require(tokenBalances[token] >= balanceBefore + fee, "Flashloan not repaid with fee");
        
        emit FlashLoan(token, recipient, amount);
        return true;
    }
}

/**
 * @title IFlashLoanReceiver
 * @dev Interface for contracts that want to receive flash loans
 */
interface IFlashLoanReceiver {
    function executeOperation(
        address token,
        uint256 amount,
        uint256 fee,
        bytes calldata data
    ) external returns (bool);
} 